### 一、字符串
- 字符串长度小于等于 0xF, 字符串内容直接存放在变量的内存中，类似OC **tagger pointer**
- 字符串长度 大于 0xF，字符串内容存放在__TEXT.string 中（常量区），字符串的地址值信息存放在 变量的后8个字节中
- dyld_stub_binder: 动态符号绑定
	- 是lazy_binder ，不用就不加载
	- 同一个符号只绑定一个
	- 绑定的过程就是把动态库中的函数地址绑定到数据段中

### 二、数组
- 一个数组变量占用8个字节的内存
- 数组中的数据放到堆中

### 三、可选项的本质

- 就是枚举关联值

### 四、高级运算符
#### 1、溢出运算符（Overflow Operator）&+、&-、&*
- Swif 算术运算符出现溢出时会抛出运行时错误
- Swift有溢出运算符 &+、&-、&*

#### 2、运算符重载（Operator Overload）
- 类、结构体、枚举都可以为现有的运算符提供自定义的实现，这个操作叫做：运算符重载 
	- 重载：函数名相同，功能不一样
- 重载必须用 **static** 修饰
- 默认是中缀运算符
- static 后加上 **prefix**， 表示前缀运算符，加上**postfix**，表示后缀运算符
- 重载 == 运算符，遵守 **Equatable** 协议，这样实现了 == ，就自动重载了 != 运算符。
- Swift中一下类型自动实现了  **Equatable**协议
	- 没有关联值的 枚举
	- 只拥有遵守**Equatable**协议的关联类型的枚举
	- 只拥有遵守**Equatable**协议的存储属性的结构体
- === 、!==： 判断是否引用着同一个对象
- **Comparable 协议**
	- 要想比较2个实例的大小，一般做法是：
		- 遵守**Comparable 协议**
		- 重载相应的运算符

#### 3、自定义运算符

`infix operator +- : PlusMinusPrecedence
precedencegroup PlusMinusPrecedence {
    associativity: left // 结合性
    higherThan: AdditionPrecedence // 比谁的优先级高
    lowerThan: MultiplicationPrecedence // 比谁的优先级低
    assignment: true // 在可选链中拥有跟赋值运算符一样的优先级
}`

### 五、扩展

#### 1、基本介绍
- Swift中的扩展，可以为枚举、结构体、类、协议 添加新的功能
	- 可以添加方法、计算属性、结构体、类、（便捷）初始化器、嵌套类型、协议等等
- 扩展不能办到的事情
	- 不能覆盖原有的功能
	- 不能添加存储属性，不能向已有的属性添加属性观察器
	- 不能添加父类
	- 不能添加指定初始化器，不能添加反初始化器
	- ...

#### 2、协议、初始化器
- 指定初始化器和便捷初始化器是类里面的概念，类只可以扩展便捷初始化器
- 结构体中，扩展了初始化器，可以保留编译器默认给生成的初始化器
- **required**初始化器不能声明在扩展中

#### 3、扩展协议
- 扩展可以给协议提供默认实现，也间接实现**可选协议**的效果
- 扩展可以给协议扩充**协议中从未声明过的方法**