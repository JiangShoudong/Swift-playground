### 继承
- 值类型（枚举、结构体）不支持继承，只有类支持继承
- 没有父类的类，称为：基类
	- Swift并没有像OC、Java那样规定：任何类最终要继承自某个类
- 子类可以重写父类的下标、方法、属性，重写必须加上 override 关键字
	- 子类可以将父类的（存储属性、计算属性）重写为**计算属性**

- **类和结构体的继承的区别**
	- 结构体不支持继承
	- 类可以继承


### 多态
- 什么是多态？
	- 父类指针指向子类对象

- 不同的语言中多态有不同的实现
	- OC 是通过runtime 来实现
	- C++是通过虚表（虚函数）实现
- Swift中多态的实现原理
	- 把方法地址放在类的类型信息里面，每个类的实例对象的前八个字节存放这个类型信息的地址。类型信息在编译完成后就确定了，运行时去查找对应方法进行调用。类似C++虚表
- 说明
	- 不需要继承的，只是简单定义一些成员变量和方法，优先考虑结构体，通过汇编可以发现结构体的方 法调用汇编实现非常简单，效率更高一些
- **类和结构体的调用方法的区别**
	- 结构体在调用方法的时候可以直接确定方法地址
	- 类在调用方法的时候并不能直接确定调用的是谁

### 初始化器
- 类、结构体、枚举都可以定义初始化器
- 类有两种初始化器
	- 指定初始化器 （designated initializer）
		- 每个类必须至少有一个指定初始化器，指定初始化器是主要初始化器
	- 便捷初始化器（convenience initializer）
		- 必须先调用指定初始化器

- 类的初始化器的相互调用规则（这样设计是为了安全）
	- 指定初始化器必须从它的直系父类调用指定初始化器
	- 便捷初始化器必须从相同的类里调用一个指定初始化器
	- 便捷初始化器**最终**必须调用一个指定的初始化器（便捷初始化器是可以相互调用的）
	- 指定初始化器不能相互调用 

- Swift为了安全，设计了两段式初始化，安全检查

- 两段式初始化
	- 第一阶段：初始化所有存储属性
		- 因为第一阶段完成之前，self 都是不安全的
		- 外层调用便捷初始化器/指定初始化器
		- 分配内存给实例，但为初始化
		- 指定初始化器确保当前类定义的所有存储属性都初始化
		- 指定初始化器调用父类的指定初始化器，确保父类定义的存储属性都初始化，不断向上调用，形成初始化链
	- 第二阶段：设置新的存储属性值
		- 第一阶段完成后，就可以使用self 进行个性化定制了

- 重写初始化器
	- 当重写父类的初始化器时，必须加上 override，（即使子类的实现是便捷初始化器）
- 自动继承
	- 如果子类没有任何指定初始化器，会自动继承父类所有的指定初始化器
	- 如果子类提供了父类所有指定初始化器的实现（要么通过方式 1. 继承  2.要么重写）
		- 子类会自动继承所有的父类便捷初始化器
	- 就算子类添加了更多的便捷初始化器，这些规则依然适用
	- 子类以便捷初始化器的形式重写父类的指定初始化器，也可以作为满足规则2的一部分

- **required**关键字
	-  用 required 修饰指定初始化器，表明其子类必须实现该初始化器（通过继承或者重写实现）
	-  如果子类重写了required初始化器时也必须加上required，不用加上 override

- 属性观察器
	- 父类的属性在它自己的初始化器中赋值不会触发属性观察器，但是在子类的初始化器中赋值会触发属性观察器

- 可失败初始化器
	- 类、结构体、枚举都可以使用 **init？**定义可失败初始化器
	- var num = Int("123"), Int("123") 就调用了可失败初始化器
	- 不允许同时定义参数标签、参数个数、参数类型相同的可失败初始化器和非可失败初始化器
	- 可以用 init！定义隐式解包的可失败初始化器

### 反初始化器 deinit
- 子类的 deinit调用完之后会调用父类的 deinit

### 可选链（Optional Chaining）
- 如果可选项为 nil，调用方法、下标、属性失败，结果为nil
- 如果可选项部位nil，调用方法、下标、属性成功，结果会被包装成可选项
	- 如果结果本来就是可选项，不会再次包装
