### 闭包表达式
`{ (参数列表) -> 返回值类型  in  函数体代码 }  `

### 闭包
- 一个函数和他所捕获的变量、常量环境组合起来，成为闭包
	- 一般是指定义在函数内部的函数
	- 一般捕获的是外层函数的局部变量/常量
- 可以把闭包想象成一个类的实例对象
	- 内存在堆空间
	- 捕获的局部变量\常量就是对象的成员变量
	- 组成闭包的函数就是类内部定义的方法
	- 如果返回值是函数类型，那么参数类型要保持统一

- 自动闭包 @autoClosure
	- 可以延迟执行自动闭包中的内容
      - @autoClosure 自动将 T 封装成闭包
	- @autoClosure 只支持 () -> T 格式的参数
	- @autoClosure 并非指支持最后一个参数
	- 空合并运算符 ？？ 就是利用了 @autoClosure
	- 有 @autoClosure 和 无 @autoClosure 构成了函数重载
	- 为了避免与期望冲突，在使用 @autoClosure 的地方，在注释中说明 @autoClosure 这个值可能会延迟执行  

### 属性
- 存储属性 （Stored Property）
	- 类似于成员变量这个概念
	- 存储在实例的内存中
	- 结构体和类可以定义存储属性
	- 枚举不可以定义存储属性（枚举的内存是用来存放关联值和case 的）
	- 必须为所有的存储属性设置一个合适的初始值
- 计算属性 （Computed Property）
	- **本质就是方法（函数）**
	- **不占用实例的内存**
	- 枚举、结构体、类都可以定义计算属性（本质就是添加方法）
	- 只读计算属性：只有get 没有set
	- 不能用let ，只能用var 声明计算属性
	- 枚举中的rawValue 就是只读计算属性，所以 rawValue 不是不占用枚举实例的内存的

- 延迟存储属性（Lazy Stored Property）
	- 使用 lazy 可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化
	- lazy 属性必须是var， 不能是let
		- let 必须是在实例初始化方法完成之前就拥有值
	- 如果多条线程同时第一次访问lazy属性
		- 无法保证属性只被初始化一次
		- 不是线程安全的
	- 注意点
		- 当结构体包含一个延迟存储属性时，只有var 才能访问延迟存储属性
			- **因为延迟存储属性初始化时需要改变结构体的内存**，let 结构体实例是不可以改变内存的，所以，只有var 才能访问延迟存储属性
	- 属性观察器（Property Observer）
		- 可以为非 **lazy**的**var**存储属性设置属性观察器
		- willSet 会传递新值，默认叫newValue
		- didSet 会传递旧值，默认叫oldValue
		- 在初始化器中设置属性不会触发willSet 和 didSet
- **inout 参数**
	- 本质是**引用传递**
	- 如果实参是有物理内存地址，且没有设置属性观察器
		- 直接将实参的内存地址传入函数（实参进行引用传递）
	- 如果实参是计算属性或者设置了属性观察器
		- 采取了Copy In Copy Out 的做法
			- 调用该函数时，先复制实参的值，产生副本
			- 将副本的引用传递到函数中，在函数内部修改副本的值
			- 函数返回后，再用副本的值覆盖实参的值。
- 属性类型
	- 实例属性
		- 存储实例属性（Stored instance Property）只能通过实例访问，每个实例中都有一份
		- 计算实例属性（Computed instance Property）

	- 类型属性  ： 只能通过类型去访问
		- **存储类型属性**（Stored Type Property)：不存储在实例中，在整个程序运行过程中，只有一份内存
			- 默认就是lazy，延迟初始化
			- 线程安全，就算是被多个线程同时访问，也只会初始化一次
			- 枚举是可以定义存储类型属性的，为什么？因为类型存储属性并不在实例中。
			- 可以用来定义单例
		- **计算类型属性**（Computed Type Property)
		- 可以通过**static** 定义类型属性
			- 如果是类的话，可以用class 定义类型属性